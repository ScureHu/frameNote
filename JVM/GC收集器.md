# 垃圾收集器

## 各种垃圾收集器的使用关系图

![](https://upload-images.jianshu.io/upload_images/650075-8c5080659578032d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/547)

## serial 收集器

#### 特点

- 新生代收集器
- 单线程垃圾回收（“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾回收，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束）
- 使用复制算法

#### 优点

- 简单而高效
- 在Client模式下的虚拟机来说是一个很好的选择

#### 可配合的老年代收集器

- CMS
- Serial Old

## ParNew 收集器

#### 特点

- 新生代收集器
- serial收集器的多线程版本（收集算法，Stop the world，对象分配规则，回收策略等都与Serial收集器完全一样）
- server模式下的虚拟机的首选的新生代收集器

#### 优点

- 目前只能与CMS收集器配合使用
- 在现在的多核CPU时代，运用起来更加高效

#### 可配合的老年代收集器

- CMS
- Serial Old

## Parallel Scavenge 收集器

#### 特点

- 新生代收集器（复制算法）
- 多线程收集器
- 可以达到一个可控制的吞吐量（吞吐量 = CPU用于运行用户代码的时间/（用户代码运行时间+垃圾收集时间））
- 适合在后台运算而不需要太多交互的任务
- 自适应调整策略也是与上面两个新生代收集器的一个重要的区别

#### 可配合的老年代收集器

- Parallel Old
- Serial Old

## Serial Old 收集器

#### 特点

- 老年代收集器
- 单线程收集器（标记-整理算法）
- 在Cilent模式下的虚拟机使用

#### Server模式下的用途

- JDK1.5之前的版本中与Parallel Scavenge收集器搭配使用
- CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure时使用

## Parallel Old 收集器

#### 特点

- 老年代收集器
- 多线程收集器（标记-整理）

#### JDK1.6之后提供的

- 和Parallel Scavenge收集器在整体应用上获得吞吐量最大化的效果

## CMS收集器

#### 特点

- 老年代收集器
- 获取最短回收停顿时间
- 使用标记-清除算法实现
- 并发收集，低停顿

#### 收集步骤

- 初始标记（stop the world）关联GC Roots能直接关联到的对象，速度快
- 并发标记  GC Roots Tracing的过程（与用户线程并发）
- 重新标记（stop the world）修正并发标记期因用户程序继续运作而导致标记变动的那一部分对象（并行多线程）
- 并发清除 （与用户线程并发）

#### 缺点

- CMS收集器对CPU资源非常敏感
- CMS收集器无法处理浮动垃圾（由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法当次收集中处理掉他们，只好留待下一次GC时再清理掉，这一部分垃圾就称为“浮动垃圾”）
- 因为使用的是标记-清除算法实现的收集器,所以收集结束时会有大量空间碎片产生，当给大对象分配内存空间的时候就会带来麻烦，所以不得不提前触发一次Full GC

## G1收集器

#### 特点

- 面向服务端应用的垃圾收集器
- 并行与并发（G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行）
- 分代收集（采用不同的方式去处理新创建的对象和已经存活一段时间、熬过多次GC的旧对象以获取更好的收集效果）
- 空间整合（整体看是基于标记-整理算法实现的收集器，从局部上看来是基于"复制"算法实现的，提供规整的可可用内存。分配大对象时不会因为无法找到连续规整的可用内存而触发下一次GC）
- 可预测的停顿（可以让使用者明确在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了）

#### G1收集的范围是新生代+老年代

- 使用G1收集器，java堆的内存布局就与其他收集器有很大的区别，它将整个Java堆划分为多个大小相等的独立区域，保留新生代和老年代的概念，但是新生代和老年代不再是物理隔离的
- G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获取的空间大小以及回收所需时间的经验值），后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的Region

#### 收集步骤

- 初始标记
- 并发标记
- 最终标记（最终标记阶段则是为了修正正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录）
- 筛选回收（首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划）
